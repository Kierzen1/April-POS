{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":["file:///D:/Projects/April-POS/src/lib/firebase-admin.ts"],"sourcesContent":["import * as admin from 'firebase-admin';\r\n\r\nconst privateKey = process.env.FIREBASE_PRIVATE_KEY;\r\nconst firebaseAdminConfig = {\r\n    projectId: process.env.FIREBASE_PROJECT_ID,\r\n    clientEmail: process.env.FIREBASE_CLIENT_EMAIL,\r\n    privateKey: privateKey ? privateKey.replace(/\\\\n/g, '\\n') : undefined,\r\n};\r\n\r\n// Use a global variable to persist the admin instance across HMR reloads\r\nconst globalForAdmin = global as unknown as { admin: typeof admin };\r\n\r\nif (!admin.apps.length) {\r\n    console.log(\"Initializing Firebase Admin SDK for project:\", firebaseAdminConfig.projectId);\r\n    try {\r\n        admin.initializeApp({\r\n            credential: admin.credential.cert(firebaseAdminConfig as any),\r\n            projectId: firebaseAdminConfig.projectId,\r\n        });\r\n        console.log(\"Firebase Admin SDK initialized successfully.\");\r\n    } catch (error) {\r\n        console.error(\"Critical: Failed to initialize Firebase Admin SDK\", error);\r\n    }\r\n}\r\n\r\nexport const adminDb = admin.firestore();\r\nexport const adminAuth = admin.auth();\r\nexport default admin;\r\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAEA,MAAM,aAAa,QAAQ,GAAG,CAAC,oBAAoB;AACnD,MAAM,sBAAsB;IACxB,WAAW,QAAQ,GAAG,CAAC,mBAAmB;IAC1C,aAAa,QAAQ,GAAG,CAAC,qBAAqB;IAC9C,YAAY,aAAa,WAAW,OAAO,CAAC,QAAQ,QAAQ;AAChE;AAEA,yEAAyE;AACzE,MAAM;AAEN,IAAI,CAAC,oLAAM,IAAI,CAAC,MAAM,EAAE;IACpB,QAAQ,GAAG,CAAC,gDAAgD,oBAAoB,SAAS;IACzF,IAAI;QACA,oLAAM,aAAa,CAAC;YAChB,YAAY,oLAAM,UAAU,CAAC,IAAI,CAAC;YAClC,WAAW,oBAAoB,SAAS;QAC5C;QACA,QAAQ,GAAG,CAAC;IAChB,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,qDAAqD;IACvE;AACJ;AAEO,MAAM,UAAU,oLAAM,SAAS;AAC/B,MAAM,YAAY,oLAAM,IAAI;uCACpB"}},
    {"offset": {"line": 77, "column": 0}, "map": {"version":3,"sources":["file:///D:/Projects/April-POS/src/lib/auth.ts"],"sourcesContent":["import { NextAuthOptions } from \"next-auth\"\r\nimport CredentialsProvider from \"next-auth/providers/credentials\"\r\nimport { adminDb } from \"@/lib/firebase-admin\"\r\nimport bcrypt from \"bcryptjs\"\r\n\r\nexport const authOptions: NextAuthOptions = {\r\n    providers: [\r\n        CredentialsProvider({\r\n            name: \"Credentials\",\r\n            credentials: {\r\n                email: { label: \"Email\", type: \"email\" },\r\n                password: { label: \"Password\", type: \"password\" }\r\n            },\r\n            async authorize(credentials) {\r\n                if (!credentials?.email || !credentials?.password) return null\r\n\r\n                const usersSnap = await adminDb.collection(\"users\").where(\"email\", \"==\", credentials.email).get();\r\n\r\n                if (usersSnap.empty) {\r\n                    console.log(`Login failed: No user found with email ${credentials.email}`);\r\n                    return null\r\n                }\r\n\r\n                const userDoc = usersSnap.docs[0];\r\n                const user = userDoc.data();\r\n\r\n                if (!user.password) {\r\n                    console.log(`Login failed: User ${credentials.email} has no password set in Firestore.`);\r\n                    return null;\r\n                }\r\n\r\n                const isValid = await bcrypt.compare(credentials.password, user.password)\r\n\r\n                if (!isValid) {\r\n                    console.log(`Login failed: Invalid password for user ${credentials.email}`);\r\n                    return null\r\n                }\r\n\r\n                return {\r\n                    id: userDoc.id,\r\n                    email: user.email,\r\n                    name: user.name,\r\n                    role: user.role,\r\n                    isActive: user.isActive\r\n                }\r\n            }\r\n        })\r\n    ],\r\n    callbacks: {\r\n        async jwt({ token, user, trigger, session }) {\r\n            if (user) {\r\n                token.id = user.id\r\n                token.role = user.role\r\n                token.isActive = user.isActive\r\n            }\r\n            return token\r\n        },\r\n        async session({ session, token }) {\r\n            if (token && session.user) {\r\n                (session.user as any).id = token.id;\r\n                (session.user as any).role = token.role;\r\n                (session.user as any).isActive = token.isActive;\r\n            }\r\n            return session\r\n        },\r\n        async signIn({ user }) {\r\n            // Allow sign-in if user is active OR is an Admin (Admin should always be active ideally, but we check role too)\r\n            // Check logic: If user is not active, they can still \"sign in\" but middleware will block them from protected pages\r\n            // This allows them to reach the \"Waiting for Activation\" page while authenticated\r\n            return true\r\n        }\r\n    },\r\n    pages: {\r\n        signIn: \"/login\",\r\n    },\r\n    session: {\r\n        strategy: \"jwt\"\r\n    },\r\n    secret: process.env.NEXTAUTH_SECRET\r\n}\r\n"],"names":[],"mappings":";;;;AACA;AACA;AACA;;;;AAEO,MAAM,cAA+B;IACxC,WAAW;QACP,IAAA,qKAAmB,EAAC;YAChB,MAAM;YACN,aAAa;gBACT,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAQ;gBACvC,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YACpD;YACA,MAAM,WAAU,WAAW;gBACvB,IAAI,CAAC,aAAa,SAAS,CAAC,aAAa,UAAU,OAAO;gBAE1D,MAAM,YAAY,MAAM,4IAAO,CAAC,UAAU,CAAC,SAAS,KAAK,CAAC,SAAS,MAAM,YAAY,KAAK,EAAE,GAAG;gBAE/F,IAAI,UAAU,KAAK,EAAE;oBACjB,QAAQ,GAAG,CAAC,CAAC,uCAAuC,EAAE,YAAY,KAAK,EAAE;oBACzE,OAAO;gBACX;gBAEA,MAAM,UAAU,UAAU,IAAI,CAAC,EAAE;gBACjC,MAAM,OAAO,QAAQ,IAAI;gBAEzB,IAAI,CAAC,KAAK,QAAQ,EAAE;oBAChB,QAAQ,GAAG,CAAC,CAAC,mBAAmB,EAAE,YAAY,KAAK,CAAC,kCAAkC,CAAC;oBACvF,OAAO;gBACX;gBAEA,MAAM,UAAU,MAAM,8IAAM,CAAC,OAAO,CAAC,YAAY,QAAQ,EAAE,KAAK,QAAQ;gBAExE,IAAI,CAAC,SAAS;oBACV,QAAQ,GAAG,CAAC,CAAC,wCAAwC,EAAE,YAAY,KAAK,EAAE;oBAC1E,OAAO;gBACX;gBAEA,OAAO;oBACH,IAAI,QAAQ,EAAE;oBACd,OAAO,KAAK,KAAK;oBACjB,MAAM,KAAK,IAAI;oBACf,MAAM,KAAK,IAAI;oBACf,UAAU,KAAK,QAAQ;gBAC3B;YACJ;QACJ;KACH;IACD,WAAW;QACP,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE;YACvC,IAAI,MAAM;gBACN,MAAM,EAAE,GAAG,KAAK,EAAE;gBAClB,MAAM,IAAI,GAAG,KAAK,IAAI;gBACtB,MAAM,QAAQ,GAAG,KAAK,QAAQ;YAClC;YACA,OAAO;QACX;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC5B,IAAI,SAAS,QAAQ,IAAI,EAAE;gBACtB,QAAQ,IAAI,CAAS,EAAE,GAAG,MAAM,EAAE;gBAClC,QAAQ,IAAI,CAAS,IAAI,GAAG,MAAM,IAAI;gBACtC,QAAQ,IAAI,CAAS,QAAQ,GAAG,MAAM,QAAQ;YACnD;YACA,OAAO;QACX;QACA,MAAM,QAAO,EAAE,IAAI,EAAE;YACjB,gHAAgH;YAChH,mHAAmH;YACnH,kFAAkF;YAClF,OAAO;QACX;IACJ;IACA,OAAO;QACH,QAAQ;IACZ;IACA,SAAS;QACL,UAAU;IACd;IACA,QAAQ,QAAQ,GAAG,CAAC,eAAe;AACvC"}},
    {"offset": {"line": 225, "column": 0}, "map": {"version":3,"sources":["file:///D:/Projects/April-POS/src/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import { authOptions } from \"@/lib/auth\"\r\nimport NextAuth from \"next-auth\"\r\n\r\nconst handler = NextAuth(authOptions)\r\n\r\nexport { handler as GET, handler as POST }\r\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAEA,MAAM,UAAU,IAAA,kJAAQ,EAAC,mIAAW"}}]
}